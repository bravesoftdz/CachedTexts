const
  STRING_ID_NONE = 0;

  PARSE_OK = 0;
  PARSE_CANCELED = 1;

type
  TCachedParser = class;
  ECachedParserStop = class(Exception);

  TCachedParser = class(TObject)
  protected
    FParseResult: Integer;
    FParseMessage: UnicodeString;
//    FLine: PNativeUInt;
//    FStoredLineValue: NativeUInt;

    procedure DoParse(const Reader: TCachedReader); virtual;
//    function GetLine: NativeUInt; {$ifdef INLINESUPPORT}inline;{$endif}
  {$ifNdef AUTOREFCOUNT}
  public
  {$endif}
    destructor Destroy; override;
  public
    procedure Cleanup; virtual;

    function Parse(const Reader: TCachedReader): Integer; overload;
    function Parse(const FileName: string): Integer; overload;
    function Parse(const Ptr: Pointer; const Size: NativeUInt): Integer; overload;
    procedure Stop(const ParseResult: Integer; const ParseMessage: UnicodeString = '');

//    property Line: NativeUInt read GetLine;
    property ParseResult: Integer read FParseResult;
    property ParseMessage: UnicodeString read FParseMessage;
  end;

 // TCachedXMLParser = class;

const
  PARSE_XML_DOCUMENT = 2{todo};

type
  TCachedXMLParser = class;

  PCachedXMLElement = ^TCachedXMLElement;
  TCachedXMLElement = object
  protected
    FData: Pointer;
    FLine: NativeUInt;
    FName: CachedByteString;
    FUserData: Pointer;

    function GetLevel: NativeUInt; {$ifdef INLINESUPPORT}inline;{$endif}
    function GetParent: PCachedXMLElement; {$ifdef INLINESUPPORT}inline;{$endif}
    function GetPath: UnicodeString;
  public
    property Line: NativeUInt read FLine;
    property Name: CachedByteString read FName;
    property UserData: Pointer read FUserData write FUserData;
    property Level: NativeUInt read GetLevel;
    property Parent: PCachedXMLElement read GetParent;
    property Path: UnicodeString read GetPath;
  end;

  PCachedXMLAttribute = ^TCachedXMLAttribute;
  TCachedXMLAttribute = object
  protected
    FElement: PCachedXMLElement;
    FName: CachedByteString;
    FValue: CachedByteString;
  public
    property Element: PCachedXMLElement read FElement;
    property Name: CachedByteString read FName;
    property Value: CachedByteString read FValue;
  end;

  TCachedXMLParser = class(TCachedParser)
  private
    FLookup: PUniConvSBCS;
  //  FData: Pointer;

  protected
    FNamesStorage: TBytes;
    FNamesStorageSize: NativeUInt;
    FNamesStoragePosition: NativeUInt;

//    function StoreName(var Name: CachedByteString): NativeInt;

//    procedure DoParse(const Reader: TCachedReader); override;

    // OnStartDocument
    // OnEndDocument

    procedure OnComment(const Parent: TCachedXMLElement; const Value: CachedByteString); virtual;
    procedure OnElement(const Element: TCachedXMLElement); virtual;
    procedure OnAttribute(const Attribute: TCachedXMLAttribute); virtual;
    // ProcessInstruction
    // DOCTYPE
    // ENTITY???
    procedure OnElementValue(const Element: TCachedXMLElement; const Value: CachedByteString); virtual;
    procedure OnElementFinish(const Element: TCachedXMLElement); virtual;

  public
//    procedure Cleanup; override;

    // single byte char set encodings lookup
    // nil in UTF8 encoding case
    property Lookup: PUniConvSBCS read FLookup;
  end;

  TCachedXMLWriter = class(TCachedWriter)

  end;

  TCachedHTMLParser = class(TObject)

  end;

  TCachedHTMLWriter = class(TCachedWriter)

  end;

  TCachedJSONParser = class(TObject)

  end;

  TCachedJSONWriter = class(TCachedWriter)

  end;

     
     
     
///////////////


(*

{ TCachedXMLElement }

function TCachedXMLElement.GetLevel: NativeUInt;
const
  {$ifdef LARGEINT}
    MAGIC = $336;
  {$else .SMALLINT}
    MAGIC = $66C;
  {$endif}
var
  Data: NativeUInt;
begin
  // Result := (NativeUInt(@Self) - NativeUInt(Data)) siv SizeOf(TCachedXMLElement);
  Data := NativeUInt(FData);
  {$ifdef CPUX64}
    Dec(Data, NativeUInt(@Self));
    Result := (NativeInt(Data) * -MAGIC) shr 16;
  {$else}
    Result := NativeUInt(@Self) - NativeUInt(Data);
    Result := (Result * MAGIC) shr 16;
  {$endif}
end;

function TCachedXMLElement.GetParent: PCachedXMLElement;
begin
  if (@Self = Pointer(FData)) then Result := nil
  else
  begin
    Result := @Self;
    Dec(Result);
  end;
end;

function TCachedXMLElement.GetPath: UnicodeString;
var
  Data, Element: PCachedXMLElement;
begin
  Element := @Self;
  Result := {$ifdef UNICODE}Format{$else}WideFormat{$endif}
            ('%s[%d]', [Element.Name.AsUnicodeString, Element.Line]);

  Data := Element.FData;
  while (Element <> Data) do
  begin
    Dec(Element);
    Result := {$ifdef UNICODE}Format{$else}WideFormat{$endif}
              ('%s[%d] - %s', [Element.Name.AsUnicodeString, Element.Line, Result]);
  end;
end; *)


(*
	// Tree node types
	enum xml_node_type
	{
		node_null,			// Empty (null) node handle
		node_document,		// A document tree's absolute root
		node_element,		// Element tag, i.e. '<node/>'
		node_pcdata,		// Plain character data, i.e. 'text'
		node_cdata,			// Character data, i.e. '<![CDATA[text]]>'
		node_comment,		// Comment tag, i.e. '<!-- text -->'
		node_pi,			// Processing instruction, i.e. '<?name?>'
		node_declaration,	// Document declaration, i.e. '<?xml version="1.0"?>'
		node_doctype		// Document type declaration, i.e. '<!DOCTYPE doc>'
	};
*)


(*
	// Parsing status, returned as part of xml_parse_result object
	enum xml_parse_status
	{
		status_ok = 0,				// No error

		status_file_not_found,		// File was not found during load_file()
		status_io_error,			// Error reading from file/stream
		status_out_of_memory,		// Could not allocate memory
		status_internal_error,		// Internal error occurred

		status_unrecognized_tag,	// Parser could not determine tag type

		status_bad_pi,				// Parsing error occurred while parsing document declaration/processing instruction
		status_bad_comment,			// Parsing error occurred while parsing comment
		status_bad_cdata,			// Parsing error occurred while parsing CDATA section
		status_bad_doctype,			// Parsing error occurred while parsing document type declaration
		status_bad_pcdata,			// Parsing error occurred while parsing PCDATA section
		status_bad_start_element,	// Parsing error occurred while parsing start element tag
		status_bad_attribute,		// Parsing error occurred while parsing element attribute
		status_bad_end_element,		// Parsing error occurred while parsing end element tag
		status_end_element_mismatch,// There was a mismatch of start-end tags (closing tag had incorrect name, some tag was not closed or there was an excessive closing tag)

		status_append_invalid_root,	// Unable to append nodes since root type is not node_element or node_document (exclusive to xml_node::append_buffer)

		status_no_document_element	// Parsing resulted in a document without element nodes
	};
*)

(*

	enum chartype_t
	{
		ct_parse_pcdata = 1,	// \0, &, \r, <
		ct_parse_attr = 2,		// \0, &, \r, ', "
		ct_parse_attr_ws = 4,	// \0, &, \r, ', ", \n, tab
		ct_space = 8,			// \r, \n, space, tab
		ct_parse_cdata = 16,	// \0, ], >, \r
		ct_parse_comment = 32,	// \0, -, >, \r
		ct_symbol = 64,			// Any symbol > 127, a-z, A-Z, 0-9, _, :, -, .
		ct_start_symbol = 128	// Any symbol > 127, a-z, A-Z, _, :
	};

	static const unsigned char chartype_table[256] =
	{
		55,  0,   0,   0,   0,   0,   0,   0,      0,   12,  12,  0,   0,   63,  0,   0,   // 0-15
		0,   0,   0,   0,   0,   0,   0,   0,      0,   0,   0,   0,   0,   0,   0,   0,   // 16-31
		8,   0,   6,   0,   0,   0,   7,   6,      0,   0,   0,   0,   0,   96,  64,  0,   // 32-47
		64,  64,  64,  64,  64,  64,  64,  64,     64,  64,  192, 0,   1,   0,   48,  0,   // 48-63
		0,   192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192, // 64-79
		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 0,   0,   16,  0,   192, // 80-95
		0,   192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192, // 96-111
		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 0, 0, 0, 0, 0,           // 112-127

		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192, // 128+
		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,
		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,
		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,
		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,
		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,
		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,
		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192
	};

	enum chartypex_t
	{
		ctx_special_pcdata = 1,   // Any symbol >= 0 and < 32 (except \t, \r, \n), &, <, >
		ctx_special_attr = 2,     // Any symbol >= 0 and < 32 (except \t), &, <, >, "
		ctx_start_symbol = 4,	  // Any symbol > 127, a-z, A-Z, _
		ctx_digit = 8,			  // 0-9
		ctx_symbol = 16			  // Any symbol > 127, a-z, A-Z, 0-9, _, -, .
	};

	static const unsigned char chartypex_table[256] =
	{
		3,  3,  3,  3,  3,  3,  3,  3,     3,  0,  2,  3,  3,  2,  3,  3,     // 0-15
		3,  3,  3,  3,  3,  3,  3,  3,     3,  3,  3,  3,  3,  3,  3,  3,     // 16-31
		0,  0,  2,  0,  0,  0,  3,  0,     0,  0,  0,  0,  0, 16, 16,  0,     // 32-47
		24, 24, 24, 24, 24, 24, 24, 24,    24, 24, 0,  0,  3,  0,  3,  0,     // 48-63

		0,  20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,    // 64-79
		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 0,  0,  0,  0,  20,    // 80-95
		0,  20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,    // 96-111
		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 0,  0,  0,  0,  0,     // 112-127

		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,    // 128+
		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20
	};

	#define PUGI__IS_CHARTYPE_IMPL(c, ct, table) (table[static_cast<unsigned char>(c)] & (ct))

	#define PUGI__IS_CHARTYPE(c, ct) PUGI__IS_CHARTYPE_IMPL(c, ct, chartype_table)
	#define PUGI__IS_CHARTYPEX(c, ct) PUGI__IS_CHARTYPE_IMPL(c, ct, chartypex_table)


  function IsCharType(c, type: byte): Boolean; inline;
  begin
    Result := (chartype_table[c] and type <> 0);
  end;

  function IsCharTypex(c, type: byte): Boolean; inline;
  begin
    Result := (chartypex_table[c] and type <> 0);
  end;

	#define PUGI__SKIPWS()			{ while (PUGI__IS_CHARTYPE(*s, ct_space)) ++s; }
	#define PUGI__OPTSET(OPT)			( optmsk & (OPT) )
	#define PUGI__PUSHNODE(TYPE)		{ cursor = append_node(cursor, alloc, TYPE); if (!cursor) PUGI__THROW_ERROR(status_out_of_memory, s); }
	#define PUGI__POPNODE()			{ cursor = cursor->parent; }
	#define PUGI__SCANFOR(X)			{ while (*s != 0 && !(X)) ++s; }
	#define PUGI__SCANWHILE(X)		{ while ((X)) ++s; }
	#define PUGI__ENDSEG()			{ ch = *s; *s = 0; ++s; }
	#define PUGI__THROW_ERROR(err, m)	return error_offset = m, error_status = err, static_cast<char_t*>(0)
	#define PUGI__CHECK_ERROR(err, m)	{ if (*s == 0) PUGI__THROW_ERROR(err, m); }


*)

(*
	PUGI__FN char_t* strconv_escape(char_t* s, gap& g)
	{
		char_t* stre = s + 1;

		switch (*stre)
		{
			case '#':	// &#...
			{
				unsigned int ucsc = 0;

				if (stre[1] == 'x') // &#x... (hex code)
				{
					stre += 2;

					char_t ch = *stre;

					if (ch == ';') return stre;

					for (;;)
					{
						if (static_cast<unsigned int>(ch - '0') <= 9)
							ucsc = 16 * ucsc + (ch - '0');
						else if (static_cast<unsigned int>((ch | ' ') - 'a') <= 5)
							ucsc = 16 * ucsc + ((ch | ' ') - 'a' + 10);
						else if (ch == ';')
							break;
						else // cancel
							return stre;

						ch = *++stre;
					}

					++stre;
				}
				else	// &#... (dec code)
				{
					char_t ch = *++stre;

					if (ch == ';') return stre;

					for (;;)
					{
						if (static_cast<unsigned int>(static_cast<unsigned int>(ch) - '0') <= 9)
							ucsc = 10 * ucsc + (ch - '0');
						else if (ch == ';')
							break;
						else // cancel
							return stre;

						ch = *++stre;
					}

					++stre;
				}

			#ifdef PUGIXML_WCHAR_MODE
				s = reinterpret_cast<char_t*>(wchar_writer::any(reinterpret_cast<wchar_writer::value_type>(s), ucsc));
			#else
				s = reinterpret_cast<char_t*>(utf8_writer::any(reinterpret_cast<uint8_t*>(s), ucsc));
			#endif

				g.push(s, stre - s);
				return stre;
			}

			case 'a':	// &a
			{
				++stre;

				if (*stre == 'm') // &am
				{
					if (*++stre == 'p' && *++stre == ';') // &amp;
					{
						*s++ = '&';
						++stre;

						g.push(s, stre - s);
						return stre;
					}
				}
				else if (*stre == 'p') // &ap
				{
					if (*++stre == 'o' && *++stre == 's' && *++stre == ';') // &apos;
					{
						*s++ = '\'';
						++stre;

						g.push(s, stre - s);
						return stre;
					}
				}
				break;
			}

			case 'g': // &g
			{
				if (*++stre == 't' && *++stre == ';') // &gt;
				{
					*s++ = '>';
					++stre;

					g.push(s, stre - s);
					return stre;
				}
				break;
			}

			case 'l': // &l
			{
				if (*++stre == 't' && *++stre == ';') // &lt;
				{
					*s++ = '<';
					++stre;

					g.push(s, stre - s);
					return stre;
				}
				break;
			}

			case 'q': // &q
			{
				if (*++stre == 'u' && *++stre == 'o' && *++stre == 't' && *++stre == ';') // &quot;
				{
					*s++ = '"';
					++stre;

					g.push(s, stre - s);
					return stre;
				}
				break;
			}

			default:
				break;
		}

		return stre;
	}

	// Utility macro for last character handling
	#define ENDSWITH(c, e) ((c) == (e) || ((c) == 0 && endch == (e)))

	PUGI__FN char_t* strconv_comment(char_t* s, char_t endch)
	{
		gap g;

		while (true)
		{
			while (!PUGI__IS_CHARTYPE(*s, ct_parse_comment)) ++s;

			if (*s == '\r') // Either a single 0x0d or 0x0d 0x0a pair
			{
				*s++ = '\n'; // replace first one with 0x0a

				if (*s == '\n') g.push(s, 1);
			}
			else if (s[0] == '-' && s[1] == '-' && ENDSWITH(s[2], '>')) // comment ends here
			{
				*g.flush(s) = 0;

				return s + (s[2] == '>' ? 3 : 2);
			}
			else if (*s == 0)
			{
				return 0;
			}
			else ++s;
		}
	}

	PUGI__FN char_t* strconv_cdata(char_t* s, char_t endch)
	{
		gap g;

		while (true)
		{
			while (!PUGI__IS_CHARTYPE(*s, ct_parse_cdata)) ++s;

			if (*s == '\r') // Either a single 0x0d or 0x0d 0x0a pair
			{
				*s++ = '\n'; // replace first one with 0x0a

				if (*s == '\n') g.push(s, 1);
			}
			else if (s[0] == ']' && s[1] == ']' && ENDSWITH(s[2], '>')) // CDATA ends here
			{
				*g.flush(s) = 0;

				return s + 1;
			}
			else if (*s == 0)
			{
				return 0;
			}
			else ++s;
		}
	}

	typedef char_t* (*strconv_pcdata_t)(char_t* );

	template <typename opt_trim, typename opt_eol, typename opt_escape> struct strconv_pcdata_impl
	{
		static char_t* parse(char_t* s)
		{
			gap g;

			char_t* begin = s;

			while (true)
			{
				while (!PUGI__IS_CHARTYPE(*s, ct_parse_pcdata)) ++s;

				if (*s == '<') // PCDATA ends here
				{
					char_t* end = g.flush(s);

					if (opt_trim::value)
						while (end > begin && PUGI__IS_CHARTYPE(end[-1], ct_space))
							--end;

					*end = 0;

					return s + 1;
				}
				else if (opt_eol::value && *s == '\r') // Either a single 0x0d or 0x0d 0x0a pair
				{
					*s++ = '\n'; // replace first one with 0x0a

					if (*s == '\n') g.push(s, 1);
				}
				else if (opt_escape::value && *s == '&')
				{
					s = strconv_escape(s, g);
				}
				else if (*s == 0)
				{
					char_t* end = g.flush(s);

					if (opt_trim::value)
						while (end > begin && PUGI__IS_CHARTYPE(end[-1], ct_space))
							--end;

					*end = 0;

					return s;
				}
				else ++s;
			}
		}
	};

	PUGI__FN strconv_pcdata_t get_strconv_pcdata(unsigned int optmask)
	{
		PUGI__STATIC_ASSERT(parse_escapes == 0x10 && parse_eol == 0x20 && parse_trim_pcdata == 0x0800);

		switch (((optmask >> 4) & 3) | ((optmask >> 9) & 4)) // get bitmask for flags (eol escapes trim)
		{
		case 0: return strconv_pcdata_impl<opt_false, opt_false, opt_false>::parse;
		case 1: return strconv_pcdata_impl<opt_false, opt_false, opt_true>::parse;
		case 2: return strconv_pcdata_impl<opt_false, opt_true, opt_false>::parse;
		case 3: return strconv_pcdata_impl<opt_false, opt_true, opt_true>::parse;
		case 4: return strconv_pcdata_impl<opt_true, opt_false, opt_false>::parse;
		case 5: return strconv_pcdata_impl<opt_true, opt_false, opt_true>::parse;
		case 6: return strconv_pcdata_impl<opt_true, opt_true, opt_false>::parse;
		case 7: return strconv_pcdata_impl<opt_true, opt_true, opt_true>::parse;
		default: assert(false); return 0; // should not get here
		}
	}

	typedef char_t* (*strconv_attribute_t)(char_t*, char_t);

	template <typename opt_escape> struct strconv_attribute_impl
	{
		static char_t* parse_wnorm(char_t* s, char_t end_quote)
		{
			gap g;

			// trim leading whitespaces
			if (PUGI__IS_CHARTYPE(*s, ct_space))
			{
				char_t* str = s;

				do ++str;
				while (PUGI__IS_CHARTYPE(*str, ct_space));

				g.push(s, str - s);
			}

			while (true)
			{
				while (!PUGI__IS_CHARTYPE(*s, ct_parse_attr_ws | ct_space)) ++s;

				if (*s == end_quote)
				{
					char_t* str = g.flush(s);

					do *str-- = 0;
					while (PUGI__IS_CHARTYPE(*str, ct_space));

					return s + 1;
				}
				else if (PUGI__IS_CHARTYPE(*s, ct_space))
				{
					*s++ = ' ';

					if (PUGI__IS_CHARTYPE(*s, ct_space))
					{
						char_t* str = s + 1;
						while (PUGI__IS_CHARTYPE(*str, ct_space)) ++str;

						g.push(s, str - s);
					}
				}
				else if (opt_escape::value && *s == '&')
				{
					s = strconv_escape(s, g);
				}
				else if (!*s)
				{
					return 0;
				}
				else ++s;
			}
		}

		static char_t* parse_wconv(char_t* s, char_t end_quote)
		{
			gap g;

			while (true)
			{
				while (!PUGI__IS_CHARTYPE(*s, ct_parse_attr_ws)) ++s;

				if (*s == end_quote)
				{
					*g.flush(s) = 0;

					return s + 1;
				}
				else if (PUGI__IS_CHARTYPE(*s, ct_space))
				{
					if (*s == '\r')
					{
						*s++ = ' ';

						if (*s == '\n') g.push(s, 1);
					}
					else *s++ = ' ';
				}
				else if (opt_escape::value && *s == '&')
				{
					s = strconv_escape(s, g);
				}
				else if (!*s)
				{
					return 0;
				}
				else ++s;
			}
		}

		static char_t* parse_eol(char_t* s, char_t end_quote)
		{
			gap g;

			while (true)
			{
				while (!PUGI__IS_CHARTYPE(*s, ct_parse_attr)) ++s;

				if (*s == end_quote)
				{
					*g.flush(s) = 0;

					return s + 1;
				}
				else if (*s == '\r')
				{
					*s++ = '\n';

					if (*s == '\n') g.push(s, 1);
				}
				else if (opt_escape::value && *s == '&')
				{
					s = strconv_escape(s, g);
				}
				else if (!*s)
				{
					return 0;
				}
				else ++s;
			}
		}

		static char_t* parse_simple(char_t* s, char_t end_quote)
		{
			gap g;

			while (true)
			{
				while (!PUGI__IS_CHARTYPE(*s, ct_parse_attr)) ++s;

				if (*s == end_quote)
				{
					*g.flush(s) = 0;

					return s + 1;
				}
				else if (opt_escape::value && *s == '&')
				{
					s = strconv_escape(s, g);
				}
				else if (!*s)
				{
					return 0;
				}
				else ++s;
			}
		}
	};
*)

(*
// DOCTYPE consists of nested sections of the following possible types:
		// <!-- ... -->, <? ... ?>, "...", '...'
		// <![...]]>
		// <!...>
		// First group can not contain nested groups
		// Second group can contain nested groups of the same type
		// Third group can contain all other groups
		char_t* parse_doctype_primitive(char_t* s)
		{
			if (*s == '"' || *s == '\'')
			{
				// quoted string
				char_t ch = *s++;
				PUGI__SCANFOR(*s == ch);
				if (!*s) PUGI__THROW_ERROR(status_bad_doctype, s);

				s++;
			}
			else if (s[0] == '<' && s[1] == '?')
			{
				// <? ... ?>
				s += 2;
				PUGI__SCANFOR(s[0] == '?' && s[1] == '>'); // no need for ENDSWITH because ?> can't terminate proper doctype
				if (!*s) PUGI__THROW_ERROR(status_bad_doctype, s);

				s += 2;
			}
			else if (s[0] == '<' && s[1] == '!' && s[2] == '-' && s[3] == '-')
			{
				s += 4;
				PUGI__SCANFOR(s[0] == '-' && s[1] == '-' && s[2] == '>'); // no need for ENDSWITH because --> can't terminate proper doctype
				if (!*s) PUGI__THROW_ERROR(status_bad_doctype, s);

				s += 4;
			}
			else PUGI__THROW_ERROR(status_bad_doctype, s);

			return s;
		}

		char_t* parse_doctype_ignore(char_t* s)
		{
			assert(s[0] == '<' && s[1] == '!' && s[2] == '[');
			s++;

			while (*s)
			{
				if (s[0] == '<' && s[1] == '!' && s[2] == '[')
				{
					// nested ignore section
					s = parse_doctype_ignore(s);
					if (!s) return s;
				}
				else if (s[0] == ']' && s[1] == ']' && s[2] == '>')
				{
					// ignore section end
					s += 3;

					return s;
				}
				else s++;
			}

			PUGI__THROW_ERROR(status_bad_doctype, s);
		}

		char_t* parse_doctype_group(char_t* s, char_t endch, bool toplevel)
		{
			assert((s[0] == '<' || s[0] == 0) && s[1] == '!');
			s++;

			while (*s)
			{
				if (s[0] == '<' && s[1] == '!' && s[2] != '-')
				{
					if (s[2] == '[')
					{
						// ignore
						s = parse_doctype_ignore(s);
						if (!s) return s;
					}
					else
					{
						// some control group
						s = parse_doctype_group(s, endch, false);
						if (!s) return s;

						// skip >
						assert(*s == '>');
						s++;
					}
				}
				else if (s[0] == '<' || s[0] == '"' || s[0] == '\'')
				{
					// unknown tag (forbidden), or some primitive group
					s = parse_doctype_primitive(s);
					if (!s) return s;
				}
				else if (*s == '>')
				{
					return s;
				}
				else s++;
			}

			if (!toplevel || endch != '>') PUGI__THROW_ERROR(status_bad_doctype, s);

			return s;
		}

		char_t* parse_exclamation(char_t* s, xml_node_struct* cursor, unsigned int optmsk, char_t endch)
		{
			// parse node contents, starting with exclamation mark
			++s;

			if (*s == '-') // '<!-...'
			{
				++s;

				if (*s == '-') // '<!--...'
				{
					++s;

					if (PUGI__OPTSET(parse_comments))
					{
						PUGI__PUSHNODE(node_comment); // Append a new node on the tree.
						cursor->value = s; // Save the offset.
					}

					if (PUGI__OPTSET(parse_eol) && PUGI__OPTSET(parse_comments))
					{
						s = strconv_comment(s, endch);

						if (!s) PUGI__THROW_ERROR(status_bad_comment, cursor->value);
					}
					else
					{
						// Scan for terminating '-->'.
						PUGI__SCANFOR(s[0] == '-' && s[1] == '-' && ENDSWITH(s[2], '>'));
						PUGI__CHECK_ERROR(status_bad_comment, s);

						if (PUGI__OPTSET(parse_comments))
							*s = 0; // Zero-terminate this segment at the first terminating '-'.

						s += (s[2] == '>' ? 3 : 2); // Step over the '\0->'.
					}
				}
				else PUGI__THROW_ERROR(status_bad_comment, s);
			}
			else if (*s == '[')
			{
				// '<![CDATA[...'
				if (*++s=='C' && *++s=='D' && *++s=='A' && *++s=='T' && *++s=='A' && *++s == '[')
				{
					++s;

					if (PUGI__OPTSET(parse_cdata))
					{
						PUGI__PUSHNODE(node_cdata); // Append a new node on the tree.
						cursor->value = s; // Save the offset.

						if (PUGI__OPTSET(parse_eol))
						{
							s = strconv_cdata(s, endch);

							if (!s) PUGI__THROW_ERROR(status_bad_cdata, cursor->value);
						}
						else
						{
							// Scan for terminating ']]>'.
							PUGI__SCANFOR(s[0] == ']' && s[1] == ']' && ENDSWITH(s[2], '>'));
							PUGI__CHECK_ERROR(status_bad_cdata, s);

							*s++ = 0; // Zero-terminate this segment.
						}
					}
					else // Flagged for discard, but we still have to scan for the terminator.
					{
						// Scan for terminating ']]>'.
						PUGI__SCANFOR(s[0] == ']' && s[1] == ']' && ENDSWITH(s[2], '>'));
						PUGI__CHECK_ERROR(status_bad_cdata, s);

						++s;
					}

					s += (s[1] == '>' ? 2 : 1); // Step over the last ']>'.
				}
				else PUGI__THROW_ERROR(status_bad_cdata, s);
			}
			else if (s[0] == 'D' && s[1] == 'O' && s[2] == 'C' && s[3] == 'T' && s[4] == 'Y' && s[5] == 'P' && ENDSWITH(s[6], 'E'))
			{
				s -= 2;

				if (cursor->parent) PUGI__THROW_ERROR(status_bad_doctype, s);

				char_t* mark = s + 9;

				s = parse_doctype_group(s, endch, true);
				if (!s) return s;

				assert((*s == 0 && endch == '>') || *s == '>');
				if (*s) *s++ = 0;

				if (PUGI__OPTSET(parse_doctype))
				{
					while (PUGI__IS_CHARTYPE(*mark, ct_space)) ++mark;

					PUGI__PUSHNODE(node_doctype);

					cursor->value = mark;

					PUGI__POPNODE();
				}
			}
			else if (*s == 0 && endch == '-') PUGI__THROW_ERROR(status_bad_comment, s);
			else if (*s == 0 && endch == '[') PUGI__THROW_ERROR(status_bad_cdata, s);
			else PUGI__THROW_ERROR(status_unrecognized_tag, s);

			return s;
		}

		char_t* parse_question(char_t* s, xml_node_struct*& ref_cursor, unsigned int optmsk, char_t endch)
		{
			// load into registers
			xml_node_struct* cursor = ref_cursor;
			char_t ch = 0;

			// parse node contents, starting with question mark
			++s;

			// read PI target
			char_t* target = s;

			if (!PUGI__IS_CHARTYPE(*s, ct_start_symbol)) PUGI__THROW_ERROR(status_bad_pi, s);

			PUGI__SCANWHILE(PUGI__IS_CHARTYPE(*s, ct_symbol));
			PUGI__CHECK_ERROR(status_bad_pi, s);

			// determine node type; stricmp / strcasecmp is not portable
			bool declaration = (target[0] | ' ') == 'x' && (target[1] | ' ') == 'm' && (target[2] | ' ') == 'l' && target + 3 == s;

			if (declaration ? PUGI__OPTSET(parse_declaration) : PUGI__OPTSET(parse_pi))
			{
				if (declaration)
				{
					// disallow non top-level declarations
					if (cursor->parent) PUGI__THROW_ERROR(status_bad_pi, s);

					PUGI__PUSHNODE(node_declaration);
				}
				else
				{
					PUGI__PUSHNODE(node_pi);
				}

				cursor->name = target;

				PUGI__ENDSEG();

				// parse value/attributes
				if (ch == '?')
				{
					// empty node
					if (!ENDSWITH(*s, '>')) PUGI__THROW_ERROR(status_bad_pi, s);
					s += (*s == '>');

					PUGI__POPNODE();
				}
				else if (PUGI__IS_CHARTYPE(ch, ct_space))
				{
					PUGI__SKIPWS();

					// scan for tag end
					char_t* value = s;

					PUGI__SCANFOR(s[0] == '?' && ENDSWITH(s[1], '>'));
					PUGI__CHECK_ERROR(status_bad_pi, s);

					if (declaration)
					{
						// replace ending ? with / so that 'element' terminates properly
						*s = '/';

						// we exit from this function with cursor at node_declaration, which is a signal to parse() to go to LOC_ATTRIBUTES
						s = value;
					}
					else
					{
						// store value and step over >
						cursor->value = value;
						PUGI__POPNODE();

						PUGI__ENDSEG();

						s += (*s == '>');
					}
				}
				else PUGI__THROW_ERROR(status_bad_pi, s);
			}
			else
			{
				// scan for tag end
				PUGI__SCANFOR(s[0] == '?' && ENDSWITH(s[1], '>'));
				PUGI__CHECK_ERROR(status_bad_pi, s);

				s += (s[1] == '>' ? 2 : 1);
			}

			// store from registers
			ref_cursor = cursor;

			return s;
		}

char_t* parse_tree(char_t* s, xml_node_struct* root, unsigned int optmsk, char_t endch)
{
	strconv_attribute_t strconv_attribute = get_strconv_attribute(optmsk);
	strconv_pcdata_t strconv_pcdata = get_strconv_pcdata(optmsk);

	char_t ch = 0;
	xml_node_struct* cursor = root;
	char_t* mark = s;

	while (*s != 0)
	{
		if (*s == '<')
		{
			++s;

		    LOC_TAG:
			if (PUGI__IS_CHARTYPE(*s, ct_start_symbol)) // '<#...'
			{
			    /*  обычный элемент, начинающийся с правильного символа */
				PUGI__PUSHNODE(node_element); // Append a new node to the tree.

				cursor->name = s;

				PUGI__SCANWHILE(PUGI__IS_CHARTYPE(*s, ct_symbol)); // Scan for a terminator.
				PUGI__ENDSEG(); // Save char in 'ch', terminate & step over.

				if (ch == '>')
				{
					// end of tag
				}
				else
                if (PUGI__IS_CHARTYPE(ch, ct_space))
				{
				LOC_ATTRIBUTES:
					while (true)
					{
						PUGI__SKIPWS(); // Eat any whitespace.

						if (PUGI__IS_CHARTYPE(*s, ct_start_symbol)) // <... #...
						{
							xml_attribute_struct* a = append_attribute_ll(cursor, alloc); // Make space for this attribute.
							if (!a) PUGI__THROW_ERROR(status_out_of_memory, s);

							a->name = s; // Save the offset.

							PUGI__SCANWHILE(PUGI__IS_CHARTYPE(*s, ct_symbol)); // Scan for a terminator.
							PUGI__CHECK_ERROR(status_bad_attribute, s); //$ redundant, left for performance

							PUGI__ENDSEG(); // Save char in 'ch', terminate & step over.
							PUGI__CHECK_ERROR(status_bad_attribute, s); //$ redundant, left for performance

							if (PUGI__IS_CHARTYPE(ch, ct_space))
							{
								PUGI__SKIPWS(); // Eat any whitespace.
								PUGI__CHECK_ERROR(status_bad_attribute, s); //$ redundant, left for performance

								ch = *s;
								++s;
							}

							if (ch == '=') // '<... #=...'
							{
								PUGI__SKIPWS(); // Eat any whitespace.

								if (*s == '"' || *s == '\'') // '<... #="...'
								{
									ch = *s; // Save quote char to avoid breaking on "''" -or- '""'.
									++s; // Step over the quote.
									a->value = s; // Save the offset.

									s = strconv_attribute(s, ch);

									if (!s) PUGI__THROW_ERROR(status_bad_attribute, a->value);

									// After this line the loop continues from the start;
									// Whitespaces, / and > are ok, symbols and EOF are wrong,
									// everything else will be detected
									if (PUGI__IS_CHARTYPE(*s, ct_start_symbol)) PUGI__THROW_ERROR(status_bad_attribute, s);
								}
								else PUGI__THROW_ERROR(status_bad_attribute, s);
							}
							else PUGI__THROW_ERROR(status_bad_attribute, s);
						}
						else if (*s == '/')
						{
							++s;

							if (*s == '>')
							{
								PUGI__POPNODE();
								s++;
								break;
							}
							else if (*s == 0 && endch == '>')
							{
								PUGI__POPNODE();
								break;
							}
							else PUGI__THROW_ERROR(status_bad_start_element, s);
						}
						else if (*s == '>')
						{
							++s;

							break;
						}
						else if (*s == 0 && endch == '>')
						{
							break;
						}
						else PUGI__THROW_ERROR(status_bad_start_element, s);
					}

					// !!!
				}
				else if (ch == '/') // '<#.../'
				{
					if (!ENDSWITH(*s, '>')) PUGI__THROW_ERROR(status_bad_start_element, s);

					PUGI__POPNODE(); // Pop.

					s += (*s == '>');
				}
				else if (ch == 0)
				{
					// we stepped over null terminator, backtrack & handle closing tag
					--s;

					if (endch != '>') PUGI__THROW_ERROR(status_bad_start_element, s);
				}
				else PUGI__THROW_ERROR(status_bad_start_element, s);
			}
			/*  либо ошибка, либо необычный элемент (по крайней мере начинается не с правильного символа) */
			else if (*s == '/')
			{
			    // закрывающийся тег!
				++s;

				// сравнение закрывающегося тега с текущим
				char_t* name = cursor->name;
				if (!name) PUGI__THROW_ERROR(status_end_element_mismatch, s);
				while (PUGI__IS_CHARTYPE(*s, ct_symbol))
				{
					if (*s++ != *name++) PUGI__THROW_ERROR(status_end_element_mismatch, s);
				}
				if (*name)
				{
					if (*s == 0 && name[0] == endch && name[1] == 0) PUGI__THROW_ERROR(status_bad_end_element, s);
					else PUGI__THROW_ERROR(status_end_element_mismatch, s);
				}

				// Pop.
				PUGI__POPNODE();

				// пропустить все пробелы
				PUGI__SKIPWS();

				if (*s == 0)
				{
					if (endch != '>') PUGI__THROW_ERROR(status_bad_end_element, s);
				}
				else
				{
					if (*s != '>') PUGI__THROW_ERROR(status_bad_end_element, s);
					++s;
				}
			}
			else
			if (*s == '?') // '<?...'
			{
			    // типа process instruction
				s = parse_question(s, cursor, optmsk, endch);
				if (!s) return s;

				assert(cursor);
				if ((cursor->header & xml_memory_page_type_mask) + 1 == node_declaration) goto LOC_ATTRIBUTES;
			}
			else
			if (*s == '!') // '<!...'
			{
			    // комментарий
				s = parse_exclamation(s, cursor, optmsk, endch);
				if (!s) return s;
			}
			else if (*s == 0 && endch == '?') PUGI__THROW_ERROR(status_bad_pi, s);
			else PUGI__THROW_ERROR(status_unrecognized_tag, s);
		}
		else /* не '<' */
		{
			mark = s; // Save this offset while searching for a terminator.

			PUGI__SKIPWS(); // Eat whitespace if no genuine PCDATA here.

			if (*s == '<' || !*s)
			{
				// We skipped some whitespace characters because otherwise we would take the tag branch instead of PCDATA one
				assert(mark != s);

				if (!PUGI__OPTSET(parse_ws_pcdata | parse_ws_pcdata_single) || PUGI__OPTSET(parse_trim_pcdata))
				{
					continue;
				}
				else if (PUGI__OPTSET(parse_ws_pcdata_single))
				{
					if (s[0] != '<' || s[1] != '/' || cursor->first_child) continue;
				}
			}

			if (!PUGI__OPTSET(parse_trim_pcdata))
				s = mark;

			if (cursor->parent || PUGI__OPTSET(parse_fragment))
			{
				PUGI__PUSHNODE(node_pcdata); // Append a new node on the tree.
				cursor->value = s; // Save the offset.

				s = strconv_pcdata(s);

				PUGI__POPNODE(); // Pop since this is a standalone.

				if (!*s) break;
			}
			else
			{
				PUGI__SCANFOR(*s == '<'); // '...<'
				if (!*s) break;

				++s;
			}

			// We're after '<'
			goto LOC_TAG;
		} /* '<' или не '<' */
	} // цикл заканчивается когда значение = 0

	// check that last tag is closed
	if (cursor != root) PUGI__THROW_ERROR(status_end_element_mismatch, s);

	return s;
} // parse_tree
*)




(*

{ TCachedParser }

destructor TCachedParser.Destroy;
begin
  Cleanup;
  inherited;
end;

procedure TCachedParser.Cleanup;
begin
  FParseResult := PARSE_OK;
  FParseMessage := '';
end;

procedure TCachedParser.DoParse(const Reader: TCachedReader);
begin
end;

procedure TCachedParser.Stop(const ParseResult: Integer; const ParseMessage: UnicodeString);
begin
  FParseResult := ParseResult;
  FParseMessage := ParseMessage;
  raise ECachedParserStop.Create({$ifdef KOL}e_Custom,{$endif}'');
end;

function TCachedParser.Parse(const Reader: TCachedReader): Integer;
begin
  Cleanup;

  try
    DoParse(Reader);
    FParseResult := PARSE_OK;
    FParseMessage := '';
  except
    on E: ECachedParserStop do ;
  end;

  Result := FParseResult;
end;

function TCachedParser.Parse(const FileName: string): Integer;
var
  Reader: TCachedFileReader;
begin
  Reader := TCachedFileReader.Create(FileName);
  try
    Result := Parse(Reader);
  finally
    Reader.Free;
  end;
end;

function TCachedParser.Parse(const Ptr: Pointer;
  const Size: NativeUInt): Integer;
var
  Static: TCachedStatic;
  Reader: TCachedReader;
begin
  Reader := TCachedReader.StaticCreate(Static, Ptr, Size);
  try
    Result := Parse(Reader);
  finally
    Reader.Free;
  end;
end;


{ TCachedXMLParser }

procedure TCachedXMLParser.OnComment(const Parent: TCachedXMLElement; const Value: CachedByteString);
begin
end;

procedure TCachedXMLParser.OnElement(const Element: TCachedXMLElement);
begin
end;

procedure TCachedXMLParser.OnAttribute(const Attribute: TCachedXMLAttribute);
begin
end;

procedure TCachedXMLParser.OnElementValue(const Element: TCachedXMLElement; const Value: CachedByteString);
begin
end;

procedure TCachedXMLParser.OnElementFinish(const Element: TCachedXMLElement);
begin
end;

//const
//  MAX_SAX_LEVEL = 16;

(*type
  PSAXData = ^TSAXData;

  // TCachedXMLElement alias
  TSAXElement = object
    Data: PSAXData;
    Line: NativeUInt;
    Name: CachedByteString;
    UserData: Pointer;
    Align: array[1..128-SizeOf(TCachedXMLElement)] of Byte;
  end;
  PSAXElement = ^TSAXElement;

  // TCachedXMLAttribute alias
  TSAXAttribute = object
    Element: PSAXElement;
    Name: CachedByteString;
    Value: CachedByteString;
  end;

  //
  TSAXInfo = record
    Self: Pointer; //TCachedXMLParser;
    Reader: Pointer; //TCachedByteTextReader;
//    TopCurrent: PAnsiChar;?

    case Integer of
    0:
    (
      OnComment: procedure(const Self: Pointer; const Parent: TCachedXMLElement; const Value: CachedByteString);
      OnElement: procedure(const Self: Pointer; const Element: TCachedXMLElement);
      OnAttribute: procedure(const Self: Pointer; const Attribute: TCachedXMLAttribute);
      OnElementValue: procedure(const Self: Pointer; const Element: TCachedXMLElement; const Value: CachedByteString);
      OnElementFinish: procedure(const Self: Pointer; const Element: TCachedXMLElement);
    );
    1:
    (
      PtrComment: Pointer;
      PtrElement: Pointer;
      PtrAttribute: Pointer;
      PtrElementValue: Pointer;
      PtrElementFinish: Pointer;
    );
  end;

  // данные должны состоять из:
  //  - буфер элементов (8)
  //  - указатель на бывшие данные
  //  - рабочие данные: линия,
  //  - общая информация (Self, калбеки, ридер, topCurrent)
  //  - информация для потенциальной ошибки
  TSAXData = record
    Elements: array[0..16-1] of TSAXElement; // TCachedXMLElement
    Parent: PSAXData;

    Line: NativeUInt;
    Attribute: TSAXAttribute;

    Storage: record
      Current: PAnsiChar;
      Element: PSAXElement;
      TopCurrent: PAnsiChar;
      Error: Integer;
    end;
    Info: TSAXInfo;
  end;

procedure SAXDataFill(var Data: TSAXData;
  const Self: TCachedXMLParser; const Reader: TCachedByteTextReader);
var
  Line: NativeUInt;
  Current: PAnsiChar;
  FOnComment: procedure(const Parent: TCachedXMLElement; const Value: CachedByteString) of object;
  FOnElement: procedure(const Element: TCachedXMLElement) of object;
  FOnAttribute: procedure(const Attribute: TCachedXMLAttribute) of object;
  FOnElementValue: procedure(const Element: TCachedXMLElement; const Value: CachedByteString) of object;
  FOnElementFinish: procedure(const Element: TCachedXMLElement) of object;
begin
  Line := Data.Line;
  Current := Reader.Current;
  FillChar(Data, sizeof(Data), 0);
  Data.Self := Pointer(Self);
  Data.Reader := Reader;
  Data.TopCurrent := Pointer(@Current[Reader.Margin-1]);
  Data.Line := Line;
//  Data.Name.Parser := Pointer(Self);
//  Data.Value.Parser := Pointer(Self);

  FOnComment := Self.OnComment;
  FOnElement := Self.OnElement;
  FOnAttribute := Self.OnAttribute;
  FOnElementValue := Self.OnElementValue;
  FOnElementFinish := Self.OnElementFinish;

  Data.PtrComment := TMethod(FOnComment).Code;
  Data.PtrElement := TMethod(FOnElement).Code;
  Data.PtrAttribute := TMethod(FOnAttribute).Code;
  Data.PtrElementValue := TMethod(FOnElementValue).Code;
  Data.PtrElementFinish := TMethod(FOnElementFinish).Code;
end;

const
  ct_parse_pcdata = 1;    // \0, and, \r, <
  ct_parse_attr = 2;      // \0, and, \r, ', "
  ct_parse_attr_ws = 4;   // \0, and, \r, ', ", \n, tab
  ct_space = 8;           // \r, \n, space, tab
  ct_parse_cdata = 16;    // \0, ], >, \r
  ct_parse_comment = 32;  // \0, -, >, \r
  ct_symbol = 64;         // Any symbol > 127, a-z, A-Z, 0-9, _, :, -, .
  ct_start_symbol = 128;  // Any symbol > 127, a-z, A-Z, _, :

  chartype_table: array[0..255] of Byte = (
    55,  0,   0,   0,   0,   0,   0,   0,      0,   12,  12,  0,   0,   63,  0,   0,   // 0-15
    0,   0,   0,   0,   0,   0,   0,   0,      0,   0,   0,   0,   0,   0,   0,   0,   // 16-31
    8,   0,   6,   0,   0,   0,   7,   6,      0,   0,   0,   0,   0,   96,  64,  0,   // 32-47
    64,  64,  64,  64,  64,  64,  64,  64,     64,  64,  192, 0,   1,   0,   48,  0,   // 48-63
    0,   192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192, // 64-79
    192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 0,   0,   16,  0,   192, // 80-95
    0,   192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192, // 96-111
    192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 0, 0, 0, 0, 0,           // 112-127

    192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192, // 128+
    192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,
    192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,
    192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,
    192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,
    192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,
    192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,
    192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192
  );

  ctx_special_pcdata = 1; // Any symbol >= 0 and < 32 (except \t, \r, \n), and, <, >
  ctx_special_attr = 2;   // Any symbol >= 0 and < 32 (except \t), and, <, >, "
  ctx_start_symbol = 4;   // Any symbol > 127, a-z, A-Z, _
  ctx_digit = 8;          // 0-9
  ctx_symbol = 16;        // Any symbol > 127, a-z, A-Z, 0-9, _, -, .

  chartypex_table: array[0..255] of Byte = (
    3,  3,  3,  3,  3,  3,  3,  3,     3,  0,  2,  3,  3,  2,  3,  3,     // 0-15
    3,  3,  3,  3,  3,  3,  3,  3,     3,  3,  3,  3,  3,  3,  3,  3,     // 16-31
    0,  0,  2,  0,  0,  0,  3,  0,     0,  0,  0,  0,  0, 16, 16,  0,     // 32-47
    24, 24, 24, 24, 24, 24, 24, 24,    24, 24, 0,  0,  3,  0,  3,  0,     // 48-63

    0,  20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,    // 64-79
    20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 0,  0,  0,  0,  20,    // 80-95
    0,  20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,    // 96-111
    20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 0,  0,  0,  0,  0,     // 112-127

    20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,    // 128+
    20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20
  );

var{const todo}
  sax_chartype_first: array[Byte] of Byte;

{
	// Parsing status, returned as part of xml_parse_result object
	enum xml_parse_status
	{
		status_unrecognized_tag,	// Parser could not determine tag type

		status_bad_pi,				// Parsing error occurred while parsing document declaration/processing instruction
		status_bad_comment,			// Parsing error occurred while parsing comment
		status_bad_cdata,			// Parsing error occurred while parsing CDATA section
		status_bad_doctype,			// Parsing error occurred while parsing document type declaration
		status_bad_pcdata,			// Parsing error occurred while parsing PCDATA section
		status_bad_start_element,	// Parsing error occurred while parsing start element tag
		status_bad_attribute,		// Parsing error occurred while parsing element attribute
		status_bad_end_element,		// Parsing error occurred while parsing end element tag
		status_end_element_mismatch,// There was a mismatch of start-end tags (closing tag had incorrect name, some tag was not closed or there was an excessive closing tag)

		status_append_invalid_root,	// Unable to append nodes since root type is not node_element or node_document (exclusive to xml_node::append_buffer)

		status_no_document_element	// Parsing resulted in a document without element nodes
	};

  }

{
	PUGI__FN const char* xml_parse_result::description() const
	{
		switch (status)
		{
		case status_no_document_element: return "No document element found";
		case status_unrecognized_tag: return "Could not determine tag type";

		case status_bad_pi: return "Error parsing document declaration/processing instruction";
		case status_bad_comment: return "Error parsing comment";
		case status_bad_cdata: return "Error parsing CDATA section";
		case status_bad_doctype: return "Error parsing document type declaration";
		case status_bad_pcdata: return "Error parsing PCDATA section";
		case status_bad_start_element: return "Error parsing start element tag";
		case status_bad_attribute: return "Error parsing element attribute";
		case status_bad_end_element: return "Error parsing end element tag";
		case status_end_element_mismatch: return "Start-end tags mismatch";



		}
	}
}

type
  // todo синхронизировать со стандартными константами ParseResult
  // скорее всего будет не TSAXError, а Integer
  TSAXError = (seNoDocument, seUnrecognized, seBadPi, seBadComment,
               seBadCData, seBadDocType, seBadPCData, seStartElement,
               seAttribute, seEndElement, seElementMitmatch);



//	#define PUGI__THROW_ERROR(err, m)	return error_offset = m, error_status = err, static_cast<char_t*>(0)
// ошибки

procedure InternalSAXThrow(var Data: TSAXData; Element: PSAXElement; Error: TSAXError);
const
  ERROR_MESSAGES: array[TSAXError] of UnicodeString = (
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    ''
  );
begin
  TCachedXMLParser(Data.Self).Stop(Ord(Error),
    PCachedXMLElement(Element).Path + ':'#13#10 + ERROR_MESSAGES[Error]
          );
 //PCachedXMLElement

end;

function InternalSAXFlush(var Data: TSAXData; Element: PSAXElement; Current: Pointer): PAnsiChar;
const
  LT = Ord('<');
  GT = Ord('>');
  QT = Ord('"');
  AP = Ord('''');
  OB = Ord('[');
  CB = Ord(']');
  MN = Ord('-');
  QS = Ord('?');
var
  Reader: TCachedByteTextReader;
  Offset: NativeInt;
  TopCurrent: PAnsiChar;
begin
  Reader := TCachedByteTextReader(Data.Reader);
  if (Reader.Finishing) then
  begin
    Result := nil;
    Exit;
  end;

  Offset := NativeInt(Current) - NativeInt(Reader.Current);
  Inc(NativeInt(Reader.Current), Offset);
  Dec(Reader.Margin, Offset);

  Reader.Flush;
  if (Reader.Margin <= 0) then
  begin
    Result := nil;
    Exit;
  end;

  // todo

  Result := Reader.Current;
  TopCurrent := Pointer(@Result[Reader.Margin-1]);
  Data.TopCurrent := TopCurrent;
  PInteger(@TopCurrent[1])^ := (LT shl 0) +
                               (GT shl 8) +
                               (QT shl 16) +
                               (AP shl 24);
  PInteger(@TopCurrent[5])^ := (OB shl 0) +
                               (CB shl 8) +
                               (MN shl 16) +
                               (QS shl 24);
end;

function InternalSAXQuestion(var Data: TSAXData; Element: PSAXElement; Current: PAnsiChar): PAnsiChar;
begin

end;

function InternalSAXExclamation(var Data: TSAXData; Element: PSAXElement; Current: PAnsiChar): PAnsiChar;
begin

end;





procedure InternalSAXParse(const ALine: NativeUInt; const AParser: TCachedXMLParser;
  const AByteTextReader: TCachedByteTextReader);
// Data.OnComment(Data.Self, Data.Value);
// Data.OnElement(Data.Self, Data.Name);
// Data.OnAttribute(Data.Self, Data.Name, Data.Value);
// Data.OnElementValue(Data.Self, Data.Value);
// Data.OnElementFinish(Data.Self);
label
  node_loop, node_pop;
const
  TEST_MASKS: array[0..SizeOf(Integer)-1] of NativeInt = ($80, $8000, $800000, Integer($80000000));
const
  LT_XOR_MASK = $3c3c3c3c; // <
  LF_XOR_MASK = $0a0a0a0a; // \n


var
  Current, TopCurrent: PAnsiChar;
  T, V, X: NativeInt;
  B: Byte;
  Data: TSAXData;
begin
  {$ifdef undef}{$REGION 'basic variables initialization'}{$endif}
  Data.Line := ALine;
  SAXDataFill(Data, AParser, AByteTextReader);

  Current := TCachedByteTextReader(Data.Reader).Current;
  TopCurrent := Data.TopCurrent;
  {$ifdef undef}{$ENDREGION}{$endif}

node_loop:
  {$ifdef undef}{$REGION 'find ''<'', increase Line value on ''\n'' character'}{$endif}
  T := PCardinal(Current)^;
  Inc(Current);
  //V := (T xor LT_XOR_MASK);
  //T := (T xor LF_XOR_MASK);
  V := T;
  T := (T xor LF_XOR_MASK);
  V := (V xor LT_XOR_MASK);
  //T := (T - $01010101) and (not T);
  //V := (V - $01010101) and (not V);
  X := T + Integer(-$01010101);
  T := not T;
  T := T and X;
  X := V + Integer(-$01010101);
  V := not V;
  V := V and X;
  // if ((V or T) and Integer($80808080) = 0) then
  V := V or T;
  if (V and Integer($80808080) = 0) then
  begin
    Inc(Current, SizeOf(Integer) - 1);
    goto node_loop;
  end else
  begin
    B := Ord(V and $80 = 0) + Ord(V and $8080 = 0) + Ord(V and $808080 = 0);
    V := B;
    Inc(Current, V);
    if (T and TEST_MASKS[V] <> 0) then
    begin
      Inc(Data.Line);
      goto node_loop;
    end;
  end;
  {$ifdef undef}{$ENDREGION}{$endif}

  {$ifdef undef}{$REGION 'parse non-opened element'}{$endif}
  // case sax_chartype_first[Byte(Current^)] of
  T := sax_chartype_first[Byte(Current^)];
  if (T < 4) then
  if (T = 0) then goto node_pop
  else
  case (T) of
    3: {'exception'}
       begin
         TCachedXMLParser(Data.Self).Stop(100500, 'msg');
         Exit;
   {0:}node_pop: {'/'}

         InternalSAXFlush(Data, nil, nil);
         goto node_loop;
       end;
    1: {'!'}
       begin
         case Byte(Current[1]) of
           Ord('['): {CDATA}
           begin

//             Data.OnElementValue(Data.Self, Data.Value);
             goto node_loop;
           end;
           Ord('-'): {Comment}
           begin

//             Data.OnComment(Data.Self, Data.Value);
             goto node_loop;
           end;
         else
           {Some}
           InternalSAXFlush(Data, nil, nil);
           Exit;
         end;
       end;
    2: {'?'}
       begin
         Inc(Data.Line);
         goto node_loop;
       end;
  end;
  {$ifdef undef}{$ENDREGION}{$endif}

  if (Current >= TopCurrent) then
  begin
    if (InternalSAXFlush(Data, nil, nil) = nil) then goto node_loop
    else
    if (Data.Line = 5) then
    raise Exception.Create('');
  end;


//  TCachedXMLParser(Data.Self).FStoredLineValue := Data.Line;
end;




procedure TCachedXMLParser.DoParse(const Reader: TCachedReader);
var
  Context: TUniConvContext;
  Static: TCachedStatic;
  ByteTextReader: TCachedByteTextReader;
begin
  // todo Context

  ByteTextReader := TCachedByteTextReader.StaticCreate(Static, Context, Reader);
  try
    InternalSAXParse(0, Self, ByteTextReader);
  finally
    ByteTextReader.Free;
  end;
end;

procedure TCachedXMLParser.Cleanup;
begin
  FNamesStoragePosition := 0;
end;

function TCachedXMLParser.StoreName(var Name: TCachedParserLiteral): NativeInt;
begin
  Result := 0;
  // todo
end;    *)



(*procedure TestMAGIC;
var
  i: integer;
  BEST_MAGIC, MAGIC: NativeUInt;
  DIF, V: NativeUInt;
  done: boolean;
  S: string;
begin
  BEST_MAGIC := 0;

  for MAGIC := 0 to High(Word) do
  begin
    done := true;

    for i := 0 to High(TSAXData(nil^).Elements) do
    begin
      DIF := i*SizeOf(TCachedXMLElement);

      V := (DIF * MAGIC) shr 16;
      if (i <> V) then
      begin
        done := false;
        break;
      end;
    end;

    if (done) then  BEST_MAGIC := MAGIC;
  end;

  if (BEST_MAGIC <> 0) then
  begin
    S := {$ifdef CPUX64}'x64'{$else}'x86'{$endif} + ' MAGIC = $' + IntToHex(BEST_MAGIC, 0);
    Clipboard.AsText := S;
    MessageBox(0, PChar(S), '', 0);
  end else
  raise Exception.Create('Fail');
end;

procedure TestElement();
var
  Data: TSAXData;
  i, L: NativeInt;
begin
  for i := 0 to High(TSAXData(nil^).Elements) do
  begin
    Data.Elements[i].Data := @Data;

    L := PCachedXMLElement(@Data.Elements[i]).Level;
    if (L <> i) then
    raise Exception.CreateFmt('I = %d, L = %d', [i, L]);
  end;

  MessageBox(0, 'Всё ништяк!', '', 0);
end;
      *)
     
     